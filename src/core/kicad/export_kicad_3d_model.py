"""
Convert 3D model from .obj format to .wrl with colors
"""

from __future__ import annotations

# Global imports
import re
import textwrap

from ..easyeda.parameters_easyeda import Ee3dModel
from .parameters_kicad_footprint import Ki3dModel

VRML_HEADER = """#VRML V2.0 utf8
# 3D model generated by EasyKiConverter (https://github.com/tangsangsimida/EasyKiConverter)
"""


def get_materials(obj_data: str) -> dict:

    material_regex = "newmtl .*?endmtl"
    matchs = re.findall(pattern=material_regex, string=obj_data, flags=re.DOTALL)

    materials = {}
    for match in matchs:
        material = {}
        for value in match.splitlines():
            if value.startswith("newmtl"):
                material_id = value.split(" ")[1]
            elif value.startswith("Ka"):
                material["ambient_color"] = value.split(" ")[1:]
            elif value.startswith("Kd"):
                material["diffuse_color"] = value.split(" ")[1:]
            elif value.startswith("Ks"):
                material["specular_color"] = value.split(" ")[1:]
            elif value.startswith("d"):
                # This isn't exactly the same as transparency, is dissolve
                # I.e. part C115366 (SW-TH_SPEF110100) has d=1, and isn't transparent
                material["transparency"] = value.split(" ")[1]

        materials[material_id] = material
    return materials


def get_vertices(obj_data: str) -> list:
    vertices_regex = "v (.*?)\n"
    matchs = re.findall(pattern=vertices_regex, string=obj_data, flags=re.DOTALL)

    return [
        " ".join([str(round(float(coord) / 2.54, 4)) for coord in vertice.split(" ")])
        for vertice in matchs
    ]


def generate_wrl_model(model_3d: Ee3dModel) -> Ki3dModel:
    """Generate WRL model with better error handling"""
    if not model_3d.raw_obj:
        return None
        
    materials = get_materials(obj_data=model_3d.raw_obj)
    vertices = get_vertices(obj_data=model_3d.raw_obj)

    raw_wrl = VRML_HEADER
    shapes = model_3d.raw_obj.split("usemtl")[1:]
    
    if not shapes:
        # 如果没有usemtl，处理整个OBJ作为单个形状
        shapes = [model_3d.raw_obj]
    
    for shape in shapes:
        lines = shape.splitlines()
        if not lines:
            continue
            
        # 获取材质，如果不存在则使用默认材质
        material_key = lines[0].replace(" ", "") if lines[0] else "default"
        material = materials.get(material_key, {
            'diffuse_color': ['0.8', '0.8', '0.8'],
            'specular_color': ['0.2', '0.2', '0.2'],
            'transparency': '0'
        })
        
        index_counter = 0
        link_dict = {}
        coord_index = []
        points = []
        
        for line in lines[1:]:
            if len(line) > 0 and line.startswith('f '):
                try:
                    face = [int(index) for index in line.replace("//", "").split(" ")[1:]]
                    face_index = []
                    for index in face:
                        if index not in link_dict:
                            link_dict[index] = index_counter
                            face_index.append(str(index_counter))
                            if index - 1 < len(vertices):
                                points.append(vertices[index - 1])
                            else:
                                points.append("0 0 0")  # 默认顶点
                            index_counter += 1
                        else:
                            face_index.append(str(link_dict[index]))
                    face_index.append("-1")
                    coord_index.append(",".join(face_index) + ",")
                except (ValueError, IndexError) as e:
                    print(f"Warning: Failed to process face line '{line}': {e}")
                    continue
        
        if not points:
            continue
            
        if points:
            points.insert(-1, points[-1])

        shape_str = textwrap.dedent(
            f"""
            Shape{{
                appearance Appearance {{
                    material  Material {{
                        diffuseColor {' '.join(material.get('diffuse_color', ['0.8', '0.8', '0.8']))}
                        specularColor {' '.join(material.get('specular_color', ['0.2', '0.2', '0.2']))}
                        ambientIntensity 0.2
                        transparency {material.get('transparency', '0')}
                        shininess 0.5
                    }}
                }}
                geometry IndexedFaceSet {{
                    ccw TRUE
                    solid FALSE
                    coord DEF co Coordinate {{
                        point [
                            {(", ").join(points)}
                        ]
                    }}
                    coordIndex [
                        {"".join(coord_index)}
                    ]
                }}
            }}"""
        )

        raw_wrl += shape_str

    return Ki3dModel(
        translation=None, rotation=None, name=model_3d.name, raw_wrl=raw_wrl
    )


class Exporter3dModelKicad:
    def __init__(self, model_3d: Ee3dModel):
        self.input = model_3d
        self.output = (
            generate_wrl_model(model_3d=model_3d)
            if model_3d and model_3d.raw_obj
            else None
        )
        self.output_step = model_3d.step

    def export(self, lib_path: str) -> None:
        """Export 3D models in both WRL and STEP formats with enhanced logging"""
        try:
            # Create 3D shapes directory if it doesn't exist
            import os
            shapes_dir = f"{lib_path}.3dshapes"
            os.makedirs(shapes_dir, exist_ok=True)
            print(f"3D shapes directory: {shapes_dir}")
            
            # Export WRL format
            if self.output and self.output.raw_wrl:
                wrl_path = f"{shapes_dir}/{self.output.name}.wrl"
                with open(wrl_path, mode="w", encoding="utf-8") as my_lib:
                    my_lib.write(self.output.raw_wrl)
                print(f"✅ Exported WRL 3D model: {wrl_path}")
            elif self.output:
                print(f"⚠️  No WRL content available for model: {self.output.name}")
            else:
                print(f"⚠️  No 3D model output available")
            
            # Export STEP format
            if self.output_step:
                step_path = f"{shapes_dir}/{self.input.name}.step"
                with open(step_path, mode="wb") as my_lib:
                    my_lib.write(self.output_step)
                print(f"✅ Exported STEP 3D model: {step_path}")
            elif self.input:
                print(f"⚠️  No STEP content available for model: {self.input.name}")
            else:
                print(f"⚠️  No 3D model input available")
                
        except Exception as e:
            print(f"❌ Error exporting 3D model: {e}")
            raise
